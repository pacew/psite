#! /usr/bin/env python3

import sys
import os
import pwd
import re
import shlex

import boto3

from pprint import PrettyPrinter
def pprint(val):
    PrettyPrinter().pprint(val)

ec2 = boto3.resource("ec2")
ec2c = ec2.meta.client
r53c = boto3.client('route53')

resp = ec2c.describe_key_pairs(Filters = [
    {
        'Name': 'tag-key',
        'Values': [ 'main' ]
    }
])
keys = resp['KeyPairs'][0]
keypair_id = keys['KeyPairId']
keypair_name = keys['KeyName']

# aws ec2 create-security-group --group-name stdsg --description "pace standard"

resp = ec2c.describe_security_groups(Filters = [
    {
        'Name': 'group-name',
        'Values': ['stdsg']
    }
])
group = resp['SecurityGroups'][0]
sg_id = group['GroupId']
sg_perms = group['IpPermissions']

def is_covered(proto, from_port, to_port):
    for perm in sg_perms:
        if proto == perm['IpProtocol']:
            if perm['FromPort'] <= from_port and to_port <= perm['ToPort']:
                return True
    return False

    
def sg_setup():
    want = [
        ("tcp", 22),
        ("tcp", 80),
        ("tcp", 443),
        ("tcp", (8000,9999)),
        ("udp", (10000,20000))
    ]
    
    for item in want:
        proto = item[0]
        if type(item[1]) == int:
            from_port = item[1]
            to_port = from_port
        else:
            from_port = item[1][0]
            to_port = item[1][1]
            
        if not is_covered(proto, from_port, to_port):
            print("add", proto, from_port, to_port)

            sg.authorize_ingress(IpPermissions=[
                {
                    'IpRanges': [
                        {'CidrIp': '0.0.0.0/0'}
                    ],
                    'IpProtocol': proto,
                    'FromPort': from_port,
                    'ToPort': to_port
                }
            ])


def find_ami():
    resp = ec2c.describe_images(
        Owners=['099720109477'],
        Filters = [
            { 'Name': 'architecture', 'Values': ['x86_64'] },
            { 'Name': 'description', 'Values': ['Canonical, Ubuntu, 18.04*'] },
            { 'Name': 'name', 'Values': ['ubuntu/images/*'] },
            { 'Name': 'state', 'Values': ['available'] },
            { 'Name': 'root-device-type', 'Values': ['ebs'] },
        ]
    )

    imgs = resp['Images']
    best = imgs[0]
    for img in resp['Images']:
        if img['CreationDate'] > best['CreationDate']:
            best = img
    ami_id = best['ImageId']
    print(ami_id, best['Description'])
    return ami_id

def find_zone(hostname):
    last2 = hostname.split(".")[-2:]
    domain_name = ".".join(last2)

    resp = r53c.list_hosted_zones()
    zones = resp['HostedZones']
    for zone in zones:
        name = zone['Name'].strip(".")
        if name == domain_name:
            return zone['Id']
    return None

def lookup_addr_in_route53(hostname):
    zone_id = find_zone(hostname)

    resp = r53c.test_dns_answer(HostedZoneId = zone_id,
                                RecordName = hostname,
                                RecordType = "A")
    data = resp['RecordData']
    if len(data) > 0:
        return data[0]
    return None

def make_eip():
    resp = ec2c.allocate_address(Domain='vpc')
    return resp

def set_route53(hostname, ipaddr):
    zone_id = find_zone(hostname)

    r53c.change_resource_record_sets(
        ChangeBatch={
            'Changes': [
                {
                    'Action': 'CREATE',
                    'ResourceRecordSet': {
                        'Name': hostname,
                        'ResourceRecords': [{'Value': ipaddr,}],
                        'TTL': 60,
                        'Type': 'A',
                    },
                },
            ]},
        HostedZoneId=zone_id)

def find_unused_eip():
    resp = ec2c.describe_addresses ()
    for addr in resp['Addresses']:
        if addr.get("AssociationId") is None:
            return addr
    return None

def find_eip_for_ipaddr(ipaddr):
    resp = ec2c.describe_addresses ()
    for addr in resp['Addresses']:
        if addr['PublicIp'] == ipaddr:
            return addr
    return None

def get_elastic_ip(hostname):
    ipaddr = lookup_addr_in_route53(hostname)

    if ipaddr is None:
        eip = find_unused_eip()
        if eip is None:
            eip = make_eip()
        setdns (hostname, eip)
        return eip

    eip = find_eip_for_ipaddr(ipaddr)
    if eip is None:
        print("{hostname} wants {ipaddr} but there's no eip for that")
        sys.exit(1)
    return eip

            
def make_script():
    p = pwd.getpwuid(os.getuid())
    aboot_user = p.pw_name
    aboot_gecos = p.pw_gecos.rstrip(",")

    s = list()
    s.append("#! /bin/bash")
    s.append("ABOOT_USER={}".format(shlex.quote(aboot_user)))
    s.append("ABOOT_GECOS={}".format(shlex.quote(aboot_gecos)))

    script = "\n".join(s)
    script += "\n\n"

    with open("aboot") as f:
        script += f.read()

    return script

def launch_instance(hostname):
    answer = input (f"launch an instance for {hostname} (y/n)? ")
    if answer != "y":
        print("aborted")
        sys.exit(1)

    script = make_script()
    
    ami_id = find_ami()

    inst = ec2c.run_instances(
        ImageId=ami_id,
        InstanceType='t2.micro',
        KeyName=keypair_name,
        MaxCount=1,
        MinCount=1,
        SecurityGroupIds=[sg_id],
        UserData=script,
        TagSpecifications=[
            {
                'ResourceType': 'instance',
                'Tags': [
                    {
                        "Key": "hostname",
                        "Value": hostname
                    }
                ]
            }
        ]
    )
    return inst


def find_instance(hostname):
    resp = ec2c.describe_instances(Filters=[
        {'Name': 'tag:hostname', 'Values': [hostname]}
    ])
    for res in resp['Reservations']:
        for inst in res['Instances']:
            if inst['State']['Name'] == "running":
                return inst
            print("skipping inst {} {}".format(inst['InstanceId'],
                                               inst['State']['Name']))
    return None

def aserver_up(hostname):
    inst = find_instance(hostname)
    if inst is None:
        print("launching...")
        inst = launch_instance(hostname)
        sys.exit(0)

    inst_id = inst['InstanceId']
    print("found inst {} {}".format(inst_id, inst['State']['Name']))

    eip = get_elastic_ip(hostname)

    if 'InstanceId' not in eip:
        print("associating eip to inst")
        ec2c.associate_address (AllocationId = eip['AllocationId'],
                                InstanceId = inst_id)

    ipaddr = eip['PublicIp']
    shortname = hostname.split(".")[0]
    print()
    print(f"ssh-keygen -qR {ipaddr}")
    print(f"ssh-keygen -qR {hostname}")
    print(f"ssh-keygen -qR {shortname}")
    print()

    print(f"try ssh ubuntu@{hostname}")

def aserver_down(hostname):
    inst = find_instance(hostname)
    if inst is None:
        print(f"{hostname} not found")
    else:
        inst_id = inst['InstanceId']
        resp = ec2c.terminate_instances(InstanceIds=[inst_id])
        print("ok")


def main():
    if len(sys.argv) != 3:
        print("usage: aserver hostname up|down")
        sys.exit (1)

    hostname = sys.argv[1]
    op = sys.argv[2]

    if op == "up":
        aserver_up(hostname)
    elif op == "down":
        aserver_down(hostname)

if __name__ == "__main__":
    main()
